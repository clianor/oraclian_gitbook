# 11 Best Freelance Python Developers for Hire

### 1. 함수 데코레이터를 사용하는 이유는?

데코레이터는 하나의 데코레이터 정의를 여러 함수나 클래스에서 적용할 수 있습니다.  
또한 데코레이터에는 일급 함수와 클로저에 대한 내용도 포함되기에 숙지할 필요가 있습니다.  
데코레이터의 예시로는 로깅, 특정 형식 적용, 타이머 등과 같은 것들이 있으며 코드를 재사용하기 좋다는 장점이 있습니다.  
제가 많이 사용했던 내용에는 아래와 같은 타이머 코드가 있었습니다.

```python
import time


def timer(func):
    def inner_func(*args, **kargs):
        start_time = time.time()

        result = func(*args, **kargs)

        end_time = time.time()

        print(f"{end_time - start_time} ms")
        return result

    return inner_func


@timer
def testFunc(n):
    s = 0

    for i in range(1000000):
        if i % 10000 == 0:
            s += i

    return (s, n)


print(f"result: {testFunc(10000)}")
# result: 
# 0.04999995231628418 ms
# (49500000, 10000)
```

### 2. 람다 표현식과 리스트 컴프리헨션 그리고 제너레이터 표현식이란 무엇인가?

먼저 람다 표현식은 익명 함수를 의미합니다.  
람다 표현식으로 인해서 코드가 간결해지기는 합니다.  
하지만 클린코드적 관점에서 보자면 람다 표현식은명확한 명칭으로 인해 구분되지 않기에 정말 간단한 코드가 아니라면 사용하지 않는 것이 좋을 듯 합니다.  
  
다음으로 리스트 컴프리헨션의 경우 성능상 일반 포문이나 내장된 map, filter 함수 등에 비해 약간의 성능적 이득을 볼 수 있습니다.  
하지만 이러한 성능보다는 한 줄로 표현되는 명확하고 간결한 코드를 표현하기에 좋으며 이터러블한 객체에 대해서 매우 명확하고 손쉽게 리스트를 만들어낼 있는 방법입니다.  
  
제너레이터 표현식은 리스트와 매우 비슷합니다.  
하지만 다른 점은 매우 큰 데이터에 적합한데 큰 데이터에 적합한 이유로는 데이터를 메모리에 한 번에 적재하지 않고 필요할 때마다 필요한 만큼씩 메모리를 사용하고 이로 인해서 메모리가 최적화됩니다.

### 3. 배열을 생성하기 위한 두 방식의 차이는 무엇인가?

```python
x = [[1,2,3,4]] * 3
print(x)
# result: [[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]]

y = [[1,2,3,4] for _ in range(3)]
print(y)
# result: [[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]]
```

이 두 방식의  차이는 간단합니다.  
먼저 첫 번째 방식은 얉은 복사 방식으로 동작하고 두 번째 방식은 독립적인 각각의 배열로 깊은 복사가 됩니다.

  
아래는 제가 테스트한 예시입니다.  
각각의 원소들의 id값을 출력해보면 첫 번째 방식은 모든 원소가 동일한 id값을 가지고 있으며 두 번째 방식은 각기 다른 id 값을 가지고 있는 모습을 볼 수 있습니다.

![](../.gitbook/assets/image.png)

